"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arePathsEqual = (path1, path2) => path1.join("-") === path2.join("-");
/**
 * Returns the largest element of an array of numbers, or undefined if the array is empty.
 */
const getMaxFromList = (nos) => {
    if (nos.length === 0) {
        return undefined;
    }
    return nos.reduce((accumulator, current) => (accumulator < current ? current : accumulator), -100000);
};
exports.getDepth = (tree) => {
    if (tree.childNodes.length === 0) {
        return 1;
    }
    // Type-casting is necessary because at this point in the function there is a guarantee
    // that tree.childNodes is not empty and therefore it has a maximum value.
    return 1 + getMaxFromList(tree.childNodes.map(exports.getDepth));
};
exports.getMaxDepth = (trees) => getMaxFromList(trees.map(exports.getDepth)) || 0;
exports.getInitialOpenPaths = (basePath) => (tree) => {
    return [
        ...(tree.initiallyOpen ? [basePath] : []),
        ...tree.childNodes.map((childTree, index) => exports.getInitialOpenPaths([...basePath, index])(childTree).reduce((paths, accumulator) => [...paths, ...accumulator], [])),
    ];
};
/**
 * Adds or removes a path from a list of paths.
 * togglePath([1, 2])([[1, 2, 3], [0]]) -> [[1, 2, 3], [0], [1, 2]]
 * togglePath([1, 2])([[1, 2], [0]]) -> [[0]]
 */
exports.togglePath = (path) => (paths) => {
    if (paths.length === 0) {
        return [path];
    }
    const [head, ...tail] = paths;
    if (exports.arePathsEqual(head, path)) {
        return tail;
    }
    return [head, ...exports.togglePath(path)(tail)];
};
exports.containsPath = (path) => (paths) => {
    if (paths.length === 0) {
        return false;
    }
    const [head, ...tail] = paths;
    if (exports.arePathsEqual(head, path)) {
        return true;
    }
    return exports.containsPath(path)(tail);
};
//# sourceMappingURL=Tree.utils.js.map