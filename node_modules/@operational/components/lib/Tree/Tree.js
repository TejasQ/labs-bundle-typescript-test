"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const Icon_1 = __importDefault(require("../Icon/Icon"));
const SmallNameTag_1 = __importDefault(require("../Internals/SmallNameTag"));
const constants_1 = __importStar(require("../utils/constants"));
const styled_1 = __importDefault(require("../utils/styled"));
const Tree_utils_1 = require("./Tree.utils");
const Container = styled_1.default("div") `
  display: block;
`;
const TreeContainer = styled_1.default("div") `
  margin: 2px 0;
`;
const TreeChildren = styled_1.default("div") `
  margin-left: 14px;
`;
const TreeItem = styled_1.default("div") `
  display: flex;
  min-height: 24px;
  align-items: center;
  margin-bottom: 2px;
  :last-child {
    margin-bottom: 0px;
  }
  ${({ theme, hasChildren, hasTag, isTopLevel, isDisabled, isReorderDropTarget }) => `
    padding: ${theme.space.base / 2}px;
    border-top: 2px solid;
    border-color: ${isReorderDropTarget ? theme.color.primary : "transparent"};
    font-size: ${hasTag ? theme.font.size.fineprint : theme.font.size.small}px;
    font-weight: ${hasTag || isTopLevel ? theme.font.weight.bold : theme.font.weight.regular};
    font-family: ${hasTag ? theme.font.family.code : theme.font.family.main};
    color: ${theme.color.text.dark};
    opacity: ${isDisabled ? "0.4" : "1.0"};
    cursor: pointer;
    :hover {
      background-color: ${theme.color.background.lighter};
    }
    & svg {
      color: ${theme.color.text.lightest};
    }
    & > svg:first-child {
      flex-shrink: 0;
      visibility: ${hasChildren ? "visible" : "hidden"};
    }
  `};
`;
const FillerTreeItem = styled_1.default("div") `
  height: 6px;
  border-top: 2px solid;
  border-color: ${props => (props.isReorderDropTarget ? props.theme.color.primary : "transparent")};
`;
const TreeLabel = styled_1.default("span") `
  padding-left: ${props => props.theme.space.base}px;
  display: inline-block;
  word-wrap: break-word;
  flex: 1;
`;
/**
 * This is a single-use close button with hard-coded padding to ensure the close icon inside stays readable.
 * @todo look into re-using and formalizing this element.
 */
const IconButton = styled_1.default("div")(({ theme, hidden_, hoverEffect }) => (Object.assign({ cursor: "pointer", width: 20, height: 20, padding: 4, borderRadius: theme.borderRadius, "& svg": {
        cursor: "pointer",
    } }, (hidden_ ? { visibility: "hidden" } : {}), (hoverEffect
    ? {
        ":hover": {
            backgroundColor: theme.color.background.light,
        },
    }
    : {}))));
/**
 * Computes all props related to drag-and-drop reordering, taking appropriate state values, state setters,
 * as well as the path that the node is currently on. Note that the first argument doesn't vary from node to node,
 * while the second indicates the current node path.
 */
const reorderDndProps = ({ onReorder, reorderSource, reorderTarget, setReorderSource, setReorderTarget, }) => (node) => onReorder
    ? Object.assign({ isReorderDropTarget: Boolean(onReorder && reorderTarget && Tree_utils_1.arePathsEqual(reorderTarget, node.path)) }, (node.filler
        ? {}
        : {
            draggable: true,
            onDragStart: () => {
                setReorderSource([...node.path]);
            },
            onDragEnd: () => {
                setReorderSource(undefined);
            },
        }), { onDragOver: (ev) => {
            ev.preventDefault();
            // Reorder source is not available when the drag source is outside this tree, and should not be handled
            if (!reorderSource) {
                return;
            }
            if (Tree_utils_1.arePathsEqual(reorderSource, node.path)) {
                return;
            }
            if (!reorderTarget) {
                setReorderTarget([...node.path]);
                return;
            }
            if (Tree_utils_1.arePathsEqual(reorderTarget, node.path)) {
                return;
            }
            setReorderTarget([...node.path]);
        }, onDragLeave: () => {
            // Reorder source is not available when the drag source is outside this tree, and should not be handled
            if (!reorderSource) {
                return;
            }
            setReorderTarget(undefined);
        }, onDrop: () => {
            setReorderSource(undefined);
            setReorderTarget(undefined);
            if (reorderSource && reorderTarget) {
                onReorder(reorderSource, reorderTarget);
            }
        } }) : {};
const TreeRecursive = ({ tree, path, recursiveTogglePath, openPaths, maxDepth, onReorder, reorderSource, reorderTarget, setReorderSource, setReorderTarget, }) => {
    const isOpen = Tree_utils_1.containsPath(path)(openPaths);
    const { label, tag, disabled, initiallyOpen, childNodes, color, onRemove } = tree, treeHtmlProps = __rest(tree, ["label", "tag", "disabled", "initiallyOpen", "childNodes", "color", "onRemove"]);
    const tagColor = constants_1.expandColor(constants_1.default, color) || "";
    return (React.createElement(TreeContainer, null,
        React.createElement(TreeItem, Object.assign({}, treeHtmlProps, { hasTag: Boolean(tree.tag), hasChildren: tree.childNodes.length > 0, isTopLevel: path.length < 2, isDisabled: Boolean(tree.disabled), isRemovable: Boolean(onRemove), isReorderDropTarget: false }, reorderDndProps({
            onReorder,
            reorderSource,
            reorderTarget,
            setReorderSource,
            setReorderTarget,
        })({ path }), { onClick: () => {
                if (treeHtmlProps.onClick) {
                    treeHtmlProps.onClick();
                }
                recursiveTogglePath(path);
            } }),
            maxDepth > 1 && (React.createElement(IconButton, { hidden_: childNodes.length === 0 },
                React.createElement(Icon_1.default, { name: isOpen ? "ChevronDown" : "Add", size: 12 }))),
            tree.tag && React.createElement(SmallNameTag_1.default, { color: tagColor }, tree.tag),
            React.createElement(TreeLabel, null, tree.label),
            onRemove && (React.createElement(IconButton, { hoverEffect: true, onClick: ev => {
                    ev.stopPropagation();
                    onRemove();
                } },
                React.createElement(Icon_1.default, { name: "No", size: 12 })))),
        isOpen &&
            tree.childNodes.length > 0 &&
            !tree.disabled && (React.createElement(TreeChildren, null,
            tree.childNodes.map((childTree, index) => (React.createElement(TreeRecursive, { key: index, tree: childTree, path: [...path, index], recursiveTogglePath: recursiveTogglePath, openPaths: openPaths, maxDepth: maxDepth, onReorder: onReorder, reorderSource: reorderSource, reorderTarget: reorderTarget, setReorderSource: setReorderSource, setReorderTarget: setReorderTarget }))),
            onReorder && (React.createElement(FillerTreeItem, Object.assign({ isReorderDropTarget: false }, reorderDndProps({
                onReorder,
                reorderSource,
                setReorderSource,
                reorderTarget,
                setReorderTarget,
            })({ path: [...path, tree.childNodes.length], filler: true }))))))));
};
class Tree extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            openPaths: this.getOpenPaths(),
        };
        this.togglePath = (path) => {
            this.setState(prevState => ({
                openPaths: Tree_utils_1.togglePath(path)(prevState.openPaths),
            }));
        };
        this.setReorderSource = (reorderSource) => {
            this.setState(() => ({
                reorderSource,
            }));
        };
        this.setReorderTarget = (reorderTarget) => {
            this.setState(() => ({
                reorderTarget,
            }));
        };
    }
    getOpenPaths() {
        return this.props.trees
            .map((tree, index) => Tree_utils_1.getInitialOpenPaths([index])(tree))
            .reduce((current, accumulator) => [...current, ...accumulator], []);
    }
    componentDidUpdate(prevProps) {
        if (Tree_utils_1.getMaxDepth(this.props.trees) !== Tree_utils_1.getMaxDepth(prevProps.trees)) {
            this.setState(() => ({
                openPaths: this.getOpenPaths(),
            }));
        }
    }
    render() {
        const _a = this.props, { trees, onReorder } = _a, props = __rest(_a, ["trees", "onReorder"]);
        return (React.createElement(Container, Object.assign({}, props),
            trees.map((tree, index) => (React.createElement(TreeRecursive, { key: index, tree: tree, path: [index], recursiveTogglePath: this.togglePath, openPaths: this.state.openPaths, maxDepth: Tree_utils_1.getMaxDepth(trees), onReorder: onReorder, reorderSource: this.state.reorderSource, setReorderSource: this.setReorderSource, reorderTarget: this.state.reorderTarget, setReorderTarget: this.setReorderTarget }))),
            onReorder && (React.createElement(FillerTreeItem, Object.assign({ isReorderDropTarget: false }, reorderDndProps({
                onReorder,
                reorderSource: this.state.reorderSource,
                setReorderSource: this.setReorderSource,
                reorderTarget: this.state.reorderTarget,
                setReorderTarget: this.setReorderTarget,
            })({ path: [trees.length], filler: true }))))));
    }
}
exports.default = Tree;
//# sourceMappingURL=Tree.js.map