"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const emotion_1 = require("emotion");
const emotion_theming_1 = require("emotion-theming");
const debounce_1 = __importDefault(require("lodash/debounce"));
const merge_1 = __importDefault(require("lodash/merge"));
const React = __importStar(require("react"));
const ErrorBoundary_1 = __importDefault(require("../Internals/ErrorBoundary"));
const Message_1 = __importDefault(require("../Internals/Message/Message"));
const Messages_1 = __importDefault(require("../Internals/Messages/Messages"));
const OperationalContext_init_1 = require("../OperationalContext/OperationalContext.init");
const Progress_1 = __importDefault(require("../Progress/Progress"));
const utils_1 = require("../utils");
const constants_1 = __importDefault(require("../utils/constants"));
const styled_1 = __importDefault(require("../utils/styled"));
const baseStylesheet = (theme) => `
* {
  box-sizing: border-box;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  font-smoothing: antialiased;
}

html,
body {
  margin: 0;
  padding: 0;
  font-family: ${theme.deprecated.fontFamily};
  font-size: 13px;
  height: 100%;
}

body {
  background-color: ${theme.deprecated.colors.background};
}

a:link,
a:visited {
  color: ${theme.deprecated.colors.info};
  text-decoration: none;
}

a:hover: {
  color: ${utils_1.darken(theme.deprecated.colors.info, 5)};
}
`;
const Container = styled_1.default("div") `
  position: relative;
  min-height: 60px;
  height: 100%;
`;
const colorByMessageType = (type) => {
    switch (type) {
        case "info":
            return "primary";
        case "success":
            return "success";
        case "error":
            return "error";
    }
};
class OperationalUI extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            windowSize: {
                width: 0,
                height: 0,
            },
            messages: [],
            isLoading: false,
        };
        /**
         *  The interval responsible for periodically checking
         *  whether any messages need to be removed from state
         */
        this.messageTimerInterval = null;
        /**
         * Explicit typing is required here in order to give the typescript compiler access to typings
         * used to work out type definitions for the debounce method.
         * @todo look into making this unnecessary.
         */
        this.handleResize = debounce_1.default(() => {
            this.onSetWindowSize();
        }, 200);
        this.setLoading = (isLoading) => {
            this.setState(() => ({ isLoading }));
        };
        this.onSetWindowSize = () => {
            this.setState(() => ({
                windowSize: { width: window.innerWidth, height: window.innerHeight },
            }));
        };
        this.pushMessage = (message) => {
            const hasSamePayload = (m) => m.message.body === message.body && m.message.type === message.type;
            this.setState(prevState => {
                const hasPreviousMessageWithSamePayload = Boolean(prevState.messages.find(hasSamePayload));
                if (hasPreviousMessageWithSamePayload) {
                    return {
                        messages: prevState.messages.map(m => {
                            if (hasSamePayload(m)) {
                                return Object.assign({}, m, { addedAt: new Date().getTime(), count: m.count + 1 });
                            }
                            else {
                                return m;
                            }
                        }),
                    };
                }
                return {
                    messages: [{ message, addedAt: new Date().getTime(), count: 1 }, ...prevState.messages],
                };
            });
            // If we don't yet have an interval, start one.
            if (!this.messageTimerInterval) {
                this.messageTimerInterval = setInterval(() => this.removeOutdatedMessages(), 2000);
            }
        };
    }
    removeOutdatedMessages() {
        if (this.props.hideMessageAfter === 0) {
            return;
        }
        const now = new Date().getTime();
        const filteredMessages = this.state.messages.filter(({ message, addedAt }) => message.type === "error" || now - addedAt < (this.props.hideMessageAfter || 10000));
        // If we're out of messages, clear the interval.
        if (!filteredMessages.length && this.messageTimerInterval) {
            clearInterval(this.messageTimerInterval);
            this.messageTimerInterval = null;
        }
        // Only run a setState if any message(s) were removed.
        if (this.state.messages.length > filteredMessages.length) {
            this.setState(() => ({ messages: filteredMessages }));
        }
    }
    componentDidCatch(error) {
        this.setState({ error });
        if (this.props.onError) {
            this.props.onError(error);
        }
    }
    componentDidMount() {
        if (!this.props.noBaseStyles) {
            emotion_1.injectGlobal(baseStylesheet(constants_1.default));
        }
        this.onSetWindowSize();
        document.body.addEventListener("resize", this.handleResize);
    }
    componentWillUnmount() {
        if (this.messageTimerInterval) {
            clearInterval(this.messageTimerInterval);
        }
        document.body.removeEventListener("resize", this.handleResize);
    }
    render() {
        const { pushState, replaceState, children, theme, errorBoundary } = this.props;
        return (React.createElement(emotion_theming_1.ThemeProvider, { theme: merge_1.default(constants_1.default, theme) }, this.state.error && errorBoundary !== false ? (React.createElement(ErrorBoundary_1.default, { error: this.state.error })) : (React.createElement(OperationalContext_init_1.Provider, { value: {
                pushState,
                replaceState,
                pushMessage: this.pushMessage,
                loading: this.state.isLoading,
                setLoading: this.setLoading,
                windowSize: this.state.windowSize,
            } },
            React.createElement(Container, null,
                this.state.isLoading && React.createElement(Progress_1.default, null),
                React.createElement(Messages_1.default, null, this.state.messages.map(({ message, count }, index) => (React.createElement(Message_1.default, { key: index, color: colorByMessageType(message.type), onClose: () => this.setState(prevState => ({
                        messages: prevState.messages.filter((_, filteredMessageIndex) => filteredMessageIndex !== index),
                    })) },
                    count > 1 ? `(${count}) ` : "",
                    message.body)))),
                children)))));
    }
}
OperationalUI.defaultProps = {
    theme: {},
    errorBoundary: true,
};
exports.default = OperationalUI;
//# sourceMappingURL=OperationalUI.js.map