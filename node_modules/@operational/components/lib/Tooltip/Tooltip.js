"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const OperationalContext_1 = __importDefault(require("../OperationalContext/OperationalContext"));
const Tooltip_Container_1 = __importDefault(require("./Tooltip.Container"));
/*
 * This class name is used as a selector when customizing the opacity for tooltips
 * that are only displayed when a particular parent of theirs is hovered.
 * The pattern replaces the https://emotion.sh/docs/babel#components-as-selectors
 * pattern to remove the need for babel plugin dependancy in projects that rely on
 * this library.
 */
exports.dangerousTooltipContainerClassName = "operational-ui-tooltip";
class Tooltip extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            bbTop: 0,
            bbLeft: 0,
            bbRight: 0,
            bbBottom: 0,
            singleLineTextWidth: 0,
        };
    }
    setDomProperties() {
        if (!this.offScreenWidthTestNode || !this.containerNode) {
            return;
        }
        const bbOffScreen = this.offScreenWidthTestNode.getBoundingClientRect();
        const bbRect = this.containerNode.getBoundingClientRect();
        this.setState({
            bbTop: bbRect.top,
            bbBottom: bbRect.bottom,
            bbLeft: bbRect.left,
            bbRight: bbRect.right,
            singleLineTextWidth: bbOffScreen.width,
        });
    }
    componentDidMount() {
        this.setDomProperties();
    }
    getPosition() {
        let position = "right";
        if (this.props.left) {
            position = "left";
        }
        if (this.props.right) {
            position = "right";
        }
        if (this.props.bottom) {
            position = "bottom";
        }
        if (this.props.top) {
            position = "top";
        }
        return position;
    }
    getDisplayPosition(windowSize) {
        let position = this.getPosition();
        /** Swap the positions of tooltips in case they are clipped in this particular viewport */
        if (this.props.smart) {
            if (this.state.bbLeft < 0 && String(position) === "left") {
                position = "right";
            }
            if (this.state.bbTop < 0 && String(position) === "top") {
                position = "bottom";
            }
            if (this.state.bbRight > windowSize.width && String(position) === "right") {
                position = "left";
            }
            if (this.state.bbBottom > windowSize.height && String(position) === "bottom") {
                position = "top";
            }
        }
        return position;
    }
    render() {
        return (React.createElement(OperationalContext_1.default, null, operationalContext => {
            const displayPosition = this.getDisplayPosition(operationalContext.windowSize);
            return (React.createElement(React.Fragment, null,
                React.createElement(Tooltip_Container_1.default, { position: "bottom", offScreenWidthTest: true, singleLineTextWidth: this.state.singleLineTextWidth, innerRef: node => {
                        this.offScreenWidthTestNode = node;
                    } },
                    React.createElement("p", null, this.props.children)),
                React.createElement(Tooltip_Container_1.default, { className: exports.dangerousTooltipContainerClassName, singleLineTextWidth: this.state.singleLineTextWidth, position: displayPosition, innerRef: node => {
                        this.containerNode = node;
                    } },
                    React.createElement("p", null, this.props.children))));
        }));
    }
}
exports.default = Tooltip;
//# sourceMappingURL=Tooltip.js.map