"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const react_copy_to_clipboard_1 = __importDefault(require("react-copy-to-clipboard"));
const Hint_1 = __importDefault(require("../Hint/Hint"));
const Icon_1 = __importDefault(require("../Icon/Icon"));
const LabelText_1 = require("../LabelText/LabelText");
const Tooltip_1 = __importDefault(require("../Tooltip/Tooltip")); // Styled components appears to have an internal bug that breaks when this is imported from index.ts
const utils_1 = require("../utils");
const mixins_1 = require("../utils/mixins");
const styled_1 = __importDefault(require("../utils/styled"));
// Rendered height taking into account paddings, font-sizes and line-height
const inputHeight = 36;
const inputWidth = 360;
const InputFieldContainer = styled_1.default("div") `
  position: relative;
  align-items: center;
  justify-content: center;
  max-width: 100%;
  ${({ fullWidth, withLabel, theme }) => `
    margin-right: ${withLabel ? 0 : theme.space.small}px;
    display: ${withLabel ? "flex" : "inline-flex"};
    width: 100%;
    max-width: ${fullWidth ? "none" : `${inputWidth}px`};
  `};
`;
const InputButton = styled_1.default("div") `
  width: ${inputHeight}px;
  /** Makes sure the button doesn't shrink when inside a flex container */
  flex: 0 0 ${inputHeight}px;
  height: ${inputHeight}px;
  top: 0px;
  left: 0px;
  display: flex;
  align-items: center;
  justify-content: center;
  ${({ theme }) => `
    background-color: ${theme.color.background.lighter};
    border-top-left-radius: ${theme.borderRadius}px;
    border-bottom-left-radius: ${theme.borderRadius}px;
    border: 1px solid;
    border-color: ${theme.color.border.default};
    color: ${theme.color.text.light};
    &:hover {
      background-color: ${theme.color.background.light};
    }
  `};
`;
const InputField = styled_1.default("input")(({ theme, disabled, isError, withIconButton, preset, clear }) => {
    const makeBackgroundColor = () => {
        if (disabled) {
            return theme.color.disabled;
        }
        if (preset) {
            return utils_1.setAlpha(0.1)(theme.color.primary);
        }
        return theme.color.white;
    };
    return Object.assign({}, (withIconButton
        ? { borderTopRightRadius: theme.borderRadius, borderBottomRightRadius: theme.borderRadius, marginLeft: -1 }
        : { borderRadius: theme.borderRadius }), { fontSize: theme.font.size.body, width: "100%", height: inputHeight, label: "input", flexGrow: 1, padding: `${theme.space.small}px ${theme.space.medium}px`, opacity: disabled ? 0.6 : 1.0, font: "inherit", border: "1px solid", borderColor: isError ? theme.color.error : theme.color.border.default, appearance: "none", fontWeight: preset ? theme.font.weight.medium : theme.font.weight.regular, color: preset ? theme.color.text.dark : theme.color.text.default, backgroundColor: makeBackgroundColor() }, (clear ? { paddingRight: 40 } : {}), { "&:focus": mixins_1.inputFocus({
            theme,
            isError,
        }) });
});
const ClearButton = styled_1.default("div") `
  position: absolute;
  top: 0; /* anchor the position to the top so the browser doesn't guess */
  right: 0; /* not 12px but 0 because we want a _box_ to attach to the end of Input and not just an X pushed in from the right */

  /* We also probably should specify the dimensions of this box */
  width: ${inputHeight}px;
  height: ${inputHeight}px;

  /* Also, let's center the contents of this box */
  display: flex;
  align-items: center;
  justify-content: center;

  cursor: pointer; /* Let the user know this is clickable */

  /* We want the user to click on thix _box_, not the icon inside it */
  > svg {
    pointer-events: none;
  }
`;
exports.initialState = {
    showTooltip: false,
};
class Input extends React.Component {
    constructor() {
        super(...arguments);
        this.state = exports.initialState;
        this.timeoutId = null;
        this.showTooltip = () => {
            if (this.timeoutId) {
                clearTimeout(this.timeoutId);
            }
            this.setState(() => ({ showTooltip: true }));
            this.timeoutId = window.setTimeout(() => {
                this.setState(() => ({ showTooltip: false }));
                this.timeoutId = null;
            }, 1000);
        };
        this.getButtonElement = () => {
            const { icon, copy, value, onIconClick } = this.props;
            const { showTooltip } = this.state;
            if (!icon && !copy) {
                return null;
            }
            return copy ? (React.createElement(react_copy_to_clipboard_1.default, { text: value || "", onCopy: this.showTooltip },
                React.createElement(InputButton, null,
                    showTooltip && React.createElement(Tooltip_1.default, { left: true }, "Copied!"),
                    React.createElement(Icon_1.default, { name: "Copy", size: 16 })))) : (React.createElement(InputButton, { onClick: onIconClick }, typeof icon === "string" ? React.createElement(Icon_1.default, { name: icon, size: 16 }) : icon));
        };
        this.getInputField = () => {
            const { fullWidth, copy, icon, label, inputRef, autoFocus, name, autoComplete, disabled, value, type, onFocus, onBlur, placeholder, error, onChange, preset, clear, labelId, } = this.props;
            const commonInputProps = {
                innerRef: inputRef,
                autoFocus,
                name,
                disabled: Boolean(disabled),
                value: value || "",
                isStandalone: !Boolean(label),
                type,
                onFocus,
                onBlur,
                placeholder,
                isError: Boolean(error),
                onChange: (ev) => {
                    if (onChange) {
                        onChange(ev.currentTarget.value);
                    }
                },
            };
            const forAttributeId = label && labelId;
            const withIconButton = Boolean(icon) || Boolean(copy);
            const inputButtonElement = this.getButtonElement();
            return (React.createElement(React.Fragment, null,
                React.createElement(InputFieldContainer, { fullWidth: fullWidth, withLabel: true },
                    inputButtonElement,
                    React.createElement(InputField, Object.assign({}, commonInputProps, { clear: clear, preset: Boolean(preset), id: forAttributeId, autoComplete: autoComplete, withIconButton: withIconButton })),
                    clear &&
                        value && (React.createElement(ClearButton, { onClick: this.props.clear },
                        React.createElement(Icon_1.default, { color: "color.text.lightest", name: "No" })))),
                error ? React.createElement(mixins_1.FormFieldError, null, error) : null));
        };
    }
    render() {
        const _a = this.props, { fullWidth, copy, icon, onIconClick, label, labelId, inputRef, autoFocus, name, hint, autoComplete, onToggle, disabled, value, type, onFocus, onBlur, placeholder, error, onChange, preset } = _a, props = __rest(_a, ["fullWidth", "copy", "icon", "onIconClick", "label", "labelId", "inputRef", "autoFocus", "name", "hint", "autoComplete", "onToggle", "disabled", "value", "type", "onFocus", "onBlur", "placeholder", "error", "onChange", "preset"]);
        const forAttributeId = label && labelId;
        if (label) {
            return (React.createElement(mixins_1.Label, Object.assign({}, props, { fullWidth: fullWidth, htmlFor: forAttributeId, left: true }),
                React.createElement(LabelText_1.LabelText, null, label),
                (hint || onToggle) && (React.createElement(mixins_1.FormFieldControls, null,
                    hint && React.createElement(Hint_1.default, null, hint),
                    onToggle ? (React.createElement(mixins_1.FormFieldControl, { onClick: () => {
                            if (onToggle) {
                                onToggle();
                            }
                        } },
                        React.createElement(Icon_1.default, { name: disabled ? "Lock" : "Unlock", size: 12 }))) : null)),
                this.getInputField()));
        }
        return this.getInputField();
    }
}
exports.default = Input;
//# sourceMappingURL=Input.js.map