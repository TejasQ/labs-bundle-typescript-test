"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tinycolor2_1 = __importDefault(require("tinycolor2"));
exports.isWhite = (color) => ["white", "#fff", "#ffffff", "hsl(0, 0%, 100%)"].indexOf(color.toLowerCase()) > -1;
// Maps strings deterministally to the same color. Avoids similar strings ending up with the same color.
exports.colorMapper = (colors) => {
    return (str) => colors[hash32FNV1aUTF(str) % colors.length];
};
/*
 * Hashing algorithm used to pair strings with colors (see `colorMapper` above), chosen
 * as a compromise between speed and low risk of having identical colors assigned for two
 * strings that are nearly identical.
 *
 * Copied from https://github.com/tjwebb/fnv-plus (MIT licensed), author Travis Webb <me@traviswebb.com>
 * This FNV-1a hash algorithm, often simply called "fnv", disperses hashes throughout
 * the 32-bit hash space with very good dispersion and is very fast.
 */
/* tslint:disable:no-bitwise */
function hash32FNV1aUTF(str) {
    let c;
    let i;
    const l = str.length;
    let t0 = 0;
    let v0 = 0x9dc5;
    let t1 = 0;
    let v1 = 0x811c;
    for (i = 0; i < l; i = i + 1) {
        c = str.charCodeAt(i);
        if (c < 128) {
            v0 ^= c;
        }
        else if (c < 2048) {
            v0 ^= (c >> 6) | 192;
            t0 = v0 * 403;
            t1 = v1 * 403;
            t1 += v0 << 8;
            v1 = (t1 + (t0 >>> 16)) & 65535;
            v0 = t0 & 65535;
            v0 ^= (c & 63) | 128;
        }
        else if ((c & 64512) === 55296 && i + 1 < l && (str.charCodeAt(i + 1) & 64512) === 56320) {
            i = i + 1;
            c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(i) & 1023);
            v0 ^= (c >> 18) | 240;
            t0 = v0 * 403;
            t1 = v1 * 403;
            t1 += v0 << 8;
            v1 = (t1 + (t0 >>> 16)) & 65535;
            v0 = t0 & 65535;
            v0 ^= ((c >> 12) & 63) | 128;
            t0 = v0 * 403;
            t1 = v1 * 403;
            t1 += v0 << 8;
            v1 = (t1 + (t0 >>> 16)) & 65535;
            v0 = t0 & 65535;
            v0 ^= ((c >> 6) & 63) | 128;
            t0 = v0 * 403;
            t1 = v1 * 403;
            t1 += v0 << 8;
            v1 = (t1 + (t0 >>> 16)) & 65535;
            v0 = t0 & 65535;
            v0 ^= (c & 63) | 128;
        }
        else {
            v0 ^= (c >> 12) | 224;
            t0 = v0 * 403;
            t1 = v1 * 403;
            t1 += v0 << 8;
            v1 = (t1 + (t0 >>> 16)) & 65535;
            v0 = t0 & 65535;
            v0 ^= ((c >> 6) & 63) | 128;
            t0 = v0 * 403;
            t1 = v1 * 403;
            t1 += v0 << 8;
            v1 = (t1 + (t0 >>> 16)) & 65535;
            v0 = t0 & 65535;
            v0 ^= (c & 63) | 128;
        }
        t0 = v0 * 403;
        t1 = v1 * 403;
        t1 += v0 << 8;
        v1 = (t1 + (t0 >>> 16)) & 65535;
        v0 = t0 & 65535;
    }
    return ((v1 << 16) >>> 0) + v0;
}
const getBrightestColor = (colors) => colors.reduce((acc, curr) => {
    if (curr.l > acc.l) {
        return curr;
    }
    return acc;
});
exports.readableTextColor = (backgroundColor, workingColors) => {
    const backgroundHsl = tinycolor2_1.default(backgroundColor).toHsl();
    const workingColorHsls = workingColors.map(color => tinycolor2_1.default(color).toHsl());
    if (backgroundHsl.a < 0.5) {
        return "#FFFFFF";
    }
    // For reasonably saturated colors on the bright side, still pick the lightest color.
    if (backgroundHsl.s > 0.4 && backgroundHsl.l < 0.75) {
        return tinycolor2_1.default(getBrightestColor(workingColorHsls)).toHexString();
    }
    return tinycolor2_1.default.mostReadable(backgroundColor, workingColors).toHexString();
};
exports.darken = (color, percentage) => tinycolor2_1.default(color)
    .darken(percentage)
    .toString();
exports.lighten = (color, percentage) => tinycolor2_1.default(color)
    .lighten(percentage)
    .toString();
exports.getBrightness = (color) => {
    const c = tinycolor2_1.default(color);
    return c.getBrightness();
};
exports.setBrightness = (color, targetBrightness) => {
    const c = tinycolor2_1.default(color);
    const brightness = c.getBrightness();
    return c.brighten((targetBrightness / brightness) * 100 - 100).toString();
};
exports.setAlpha = (amount) => (color) => tinycolor2_1.default(color)
    .setAlpha(amount)
    .toString();
//# sourceMappingURL=color.js.map